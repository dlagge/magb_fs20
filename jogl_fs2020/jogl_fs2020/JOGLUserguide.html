<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0037)http://jogamp.org/jogl/doc/userguide/ -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><HTML
xmlns="http://www.w3.org/1999/xhtml"><HEAD><META content="IE=11.0000"
http-equiv="X-UA-Compatible">

<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<LINK href="style.css" rel="stylesheet" type="text/css">
       <TITLE>JOGL Userguide</TITLE>
<META name="GENERATOR" content="MSHTML 11.00.9600.16428"></HEAD>
<BODY>
<DIV id="container">
<DIV id="header">
<DIV id="slogan">JOGL Userguide</DIV>
<DIV id="logo"><A href="http://jogamp.org/">JOGL Userguide</A></DIV></DIV>
<DIV id="menu">
<UL>
  <LI><A href="http://jogamp.org/">Home</A></LI>
  <LI><A href="http://jogamp.org/gluegen/www/">Gluegen</A></LI>
  <LI><A href="http://jogamp.org/joal/www/">JOAL</A></LI>
  <LI><A href="http://jogamp.org/jocl/www/">JOCL</A></LI>
  <LI><A href="http://jogamp.org/jogl/www/">JOGL</A></LI>
  <LI><A href="http://jogamp.org/demos/www/">Demos</A></LI>
  <LI><A href="http://jogamp.org/wiki/">Wiki</A></LI>
  <LI><A
  href="http://jogamp.org/deployment/jogl-next/javadoc_public/">JavaDoc</A></LI></UL></DIV>
<DIV id="main">
<DIV class="fill" id="text"><B><FONT color="red">WARNING: This document is under
review.</FONT></B>                     <BR><BR>
<UL>
  <LI><A href="http://jogamp.org/jogl/doc/userguide/#overview">Overview</A>
</LI>
  <LI><A href="http://jogamp.org/jogl/doc/userguide/#access">Accessing JOGL</A>

  <UL>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#building">Building the
    source tree</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#localinstallation">Local
    installation</A>
    <UL>
      <LI><A href="http://jogamp.org/jogl/doc/userguide/#archivefiles">7z
      Archives</A></LI>
      <LI><A
      href="http://jogamp.org/jogl/doc/userguide/#jarfilesandclasspath">JAR
      Files &amp; CLASSPATH</A>
      <UL>
        <LI><A
        href="http://jogamp.org/jogl/doc/userguide/#atomicjarfiles">Atomic JAR
        files</A></LI></UL></LI>
      <LI><A href="http://jogamp.org/jogl/doc/userguide/#automatednativelibraryloading">Automated
      Native Library Loading</A></LI>
      <LI><A href="http://jogamp.org/jogl/doc/userguide/#traditionallibraryloading">Traditional
      Native Library Loading</A></LI>
      <LI><A href="http://jogamp.org/jogl/doc/userguide/#ideusers">Settings for
      IDE's users</A></LI>
      <LI><A href="http://jogamp.org/jogl/doc/userguide/#badpractice">Bad
      practice</A></LI>
      <LI><A
      href="http://jogamp.org/jogl/doc/userguide/#notefordebianusers">Note for
      Debian Linux users</A></LI></UL></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#onlinedeployment">Online
    Deployment</A>
    <UL>
      <LI><A
      href="http://jogamp.org/jogl/doc/userguide/#applets">Applets</A></LI>
      <LI><A href="http://jogamp.org/jogl/doc/userguide/#jnlpwebstart">JNLP /
      Web Start</A></LI></UL></LI></UL></LI>
  <LI><A href="http://jogamp.org/jogl/doc/userguide/#joglapi">Using the JOGL
  API</A>
  <UL>
    <LI><A
    href="http://jogamp.org/jogl/doc/userguide/#gldrawableandglcontext">GLDrawable
    and GLContext</A></LI>
    <LI><A
    href="http://jogamp.org/jogl/doc/userguide/#glprofile">GLProfile</A></LI>
    <LI><A
    href="http://jogamp.org/jogl/doc/userguide/#creatingaglautodrawable">Creating
    a GLAutoDrawable</A></LI>
    <LI><A
    href="http://jogamp.org/jogl/doc/userguide/#writingagleventlistener">Writing
    a GLEventListener</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#checkingextensionsandfunctionsavailability">Checking
    extensions and functions availability</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#useofniobuffers">Use of
    NIO buffers</A></LI>
    <LI><A
    href="http://jogamp.org/jogl/doc/userguide/#documentationofclang">Documentation
    of C language functions matching with Jogl methods</A></LI>
    <LI><A
    href="http://jogamp.org/jogl/doc/userguide/#performance">Performance</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#composablepipeline">Using
    the Composable Pipeline</A></LI>
    <LI><A
    href="http://jogamp.org/jogl/doc/userguide/#heavylightweightissues">Heavyweight
    and Lightweight Issues</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#swtawtissues">SWT/AWT
    issues</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#multithreadingissues">AWT
    Multithreading Issues</A></LI>
    <LI><A
    href="http://jogamp.org/jogl/doc/userguide/#pbuffers">Pbuffers</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#glu">GLU</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#moreresources">More
    Resources</A></LI></UL></LI>
  <LI><A href="http://jogamp.org/jogl/doc/userguide/#platformnotes">Platform
  notes</A>
  <UL>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#allplatforms">All
    Platforms</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#windows">Windows</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#x11unix">X11 Platforms
    (Linux, Solaris, ..)</A></LI>
    <LI><A href="http://jogamp.org/jogl/doc/userguide/#macosx">Macintosh OS
    X</A></LI></UL></LI>
  <LI><A href="http://jogamp.org/jogl/doc/userguide/#versionhistory">Version
  History</A></LI></UL>
<H2><A name="overview">Overview</A> </H2>
<P>    The JOGL project hosts the development version of the Java™ Binding for
the OpenGL® API,    and is designed to provide hardware-supported 3D graphics to
applications written in Java. </P>
<P>    It provides full access to the APIs in the OpenGL 1.3 - 3.0, 3.1 - 3.3, ?
4.0, ES 1.x and ES 2.x specification    as well as nearly all vendor extensions.
    <A
href="http://jogamp.org/jogl/doc/Overview-OpenGL-Evolution-And-JOGL.html">OpenGL
Evolution &amp; JOGL</A>    (<A href="http://jogamp.org/jogl/doc/bouml/html-svg/fig128069.svg">UML</A>)
gives you a brief overview of OpenGL,     its profiles and how we map them to
JOGL. </P>
<P>    It integrates with the AWT, Swing and SWT widget sets, as well with
custom windowing toolkits using the NativeWindow API.     <A href="http://jogamp.org/jogl/doc/NEWT-Overview.html">JOGL
also provides its own native windowing toolkit, NEWT</A>. </P>
<P>AWT integration is available via AWT GLCanvas and NEWT's NewtCanvasAWT, where
Swing integration is available via GLJPanel. </P>
<P>SWT integration is available via SWT GLCanvas and by using the SWT/AWT
brigde. </P>
<P>Other windowing systems or widgets sets can be implemented by using the
NativeWindow API. </P>
<P>Jogl provides access to the latest OpenGL routines (OpenGL 4.x with nearly
all vendor extensions) as well as platform-independent access to
hardware-accelerated offscreen rendering ("pbuffers"). Jogl also provides some
of the most popular features introduced by other Java bindings for OpenGL like
GL4Java, LWJGL and Magician, including a composable pipeline model which can
provide faster debugging for Java-based OpenGL applications than the analogous C
program and a native windowing  toolkit independent of AWT called NEWT. </P>Jogl
is designed for the most recent versions of the Java platform and for this
reason supports only:
<UL>
  <LI>Java 1.6 (Level 6.0)
  <UL>
    <LI> J2SE ? 1.6 (OpenJDK, Oracle, ..)</LI>
    <LI> JavaSE ? 1.6 For Embedded (Oracle) </LI></UL></LI>
  <LI>Android SDK API Level 9 (Version 2.3 Gingerbread)</LI></UL>
<P>It also only supports truecolor (15 bits per pixel and higher) rendering; it
does not support color-indexed modes. It was designed with New I/O (NIO) in mind
and often uses NIO internally in the implementation. Nevertheless non
 NIO/direct buffers/arrays are supported as well, since they allow faster
processing on  CPU intensive tasks.   The Jogl binding is itself written almost
completely in the Java programming language. Most of the native code is
autogenerated during the build process by a new tool called <A href="http://jogamp.org/gluegen/www/">GlueGen</A>,
the source code of which is available from its own jogamp.org project. </P>
<H2><A name="access">Accessing JOGL</A> </H2>
<H3><A name="building">Building the source tree</A> </H3>
<P>Most developers using JOGL will download the most current  <A href="http://jogamp.org/deployment/jogamp-current/archive/">release
build</A>.  Separate instructions are available on how to  <A href="http://jogamp.org/jogl/doc/HowToBuild.html">build
the source tree</A>. </P>
<H3><A name="localinstallation">Local Installation</A> </H3>See <A href="http://jogamp.org/jogl/doc/deployment/JOGL-DEPLOYMENT.html">deployment</A>
for deployment details.
<H4><A name="archivefiles">7zip Archives</A> </H4>
<P>A 7zip archive for all platforms and all JogAmp modules including JOGL is
available, named <CODE>jogamp-all-platforms.7z</CODE>,  as available <A href="http://jogamp.org/deployment/jogamp-current/archive/jogamp-all-platforms.7z">here</A>.
 It contains the Java classes to call OpenGL from Java, as well as the
associated JNI native libraries. JOGL depends on some run-time support classes
and native code provided by the GlueGen project; these classes and native code
are also provided in the 7zip bundles. </P>
<H4><A name="jarfilesandclasspath">JAR Files &amp; CLASSPATH</A> </H4>Modify
your <CODE>CLASSPATH</CODE> environment variable to include the full paths to
<CODE>gluegen-rt.jar</CODE> and <CODE>jogl-all.jar</CODE>, for example
<PRE>".;C:\Some\Other\Package\foo.jar;C:\Users\myhome\jogamp-all-platforms\jar\gluegen-rt.jar;C:\Users\myhome\jogamp-all-platforms\jar\jogl-all.jar".
</PRE>
(If you did not previously set the CLASSPATH environment variable, you may want
to make sure that ".", the current directory, is on your new CLASSPATH.) The
path separator is ":" under Solaris, Mac and Linux.
<H5><A name="atomicjarfiles">Atomic JAR files</A> </H5>
<P>Note that the 7zip archive contain more jar files than just the above
mentioned. Additional atomic jars <CODE>jogamp-all-platforms/jar/atomic/</CODE>
 illustrate how JOGL may be partitioned to achieve a smaller deployment size, in
particular on smaller devices. See <A href="http://jogamp.org/jogl/doc/deployment/JOGL-DEPLOYMENT.html">deployment</A>
for details. </P>
<H4><A name="automatednativelibraryloading">Automated Native Library Loading</A>
</H4>
<P>JOGL 2.0 has a brand new feature allowing to automatically extract the proper
native  libraries required to use JOGL  <A href="http://jogamp.org/jogl/doc/deployment/JOGL-DEPLOYMENT.html#NativeJARFiles">from
JARs containing them</A> without relying on the Java  library path or any
platform-dependent environment variable allowing to set the location  of native
libraries. This allows desktop applications as well as traditional Applets  <A
href="http://jogamp.org/jogl/doc/deployment/JOGL-DEPLOYMENT.html#NApplets">as
NApplets</A> to utilize the native library JAR files the same way Webstart/JNLP
does. </P>
<P>To allow the native JAR file library loading to work, ensure that all JogAmp
JAR files are left unmodified within their common directory. </P>
<P>In case the native library JAR files cannot be opened, it falls back to the
traditional  native library loading mechanism via the java library path. </P>
<P>This feature is enabled by default and - for whatever reason - it can be
disabled by setting the  property <CODE>jogamp.gluegen.UseTempJarCache</CODE> to
false (as a VM argument, <CODE>-Djogamp.gluegen.UseTempJarCache=false</CODE> in
command line). </P>
<H4><A name="traditionallibraryloading">Traditional Native Library Loading</A>
</H4>
<P>If you don't use <A href="http://jogamp.org/jogl/doc/userguide/#automatednativelibraryloading">automatic
native libraries loading</A>, as enabled by default, you must set either the VM
property <CODE>java.library.path</CODE> or the platform-dependent environment
variable used for the location of native libraries, <CODE>PATH</CODE> on
Windows, <CODE>LD_LIBRARY_PATH</CODE> on Unix (Linux, Solaris, ..) and
<CODE>DYLD_LIBRARY_PATH</CODE> on Mac OS X. The environment variable shall
contain the full path to the "lib" directory; for example, on Windows, add
<CODE>"C:\Users\myhome\jogamp-all-platforms\lib\windows-amd64"</CODE> to your
PATH using the System control panel, Advanced tab, Environment Variables button.
At this point your Java installation should be able to see the Jogl class files.
</P>
<H4><A name="ideusers">Settings for IDE's users</A> </H4>
<P>Eclipse users must add the JARs containing Java libraries into the Java
 Build Path of their project. They must set the native library location  of
these JARs if they have disabled the automatic extraction of native  libraries.
Netbeans users must add the JARs containing Java libraries  into their project.
In the “project” tab, select the "Libraries" node,  select the item "Add
JAR/Folder" and select the required JARs. Users of  other IDEs should consult
the IDE's documentation to see how to add jar  files and native libraries to
their current project. </P>
<H4><A name="badpractice">Bad practice</A> </H4>
<P>Dropping the JOGL jars and native libraries into the extension directory of
the JRE is <B>strongly discouraged</B>. Doing so will cause conflicts with
third-party applications launched via Java Web Start, and causes confusion later
when upgrading the distribution. </P>
<P>If you are on the Linux platform, please see the Linux-specific platform
notes, below, with information on incompatibility between the JPackage Java RPMs
and JOGL.  </P>
<H4><A name="notefordebianusers">Note for Debian Linux users</A> </H4>
<P>DEB packages are available for this distribution on its official
repositories. </P>
<H3><A name="onlinedeployment">Online Deployment</A> </H3>The recommended
distribution vehicle for <I>online</I> applications using JOGL is either using
Applets or Java Web Start. JOGL-based applications do not even need to be
signed; all that is necessary is to reference the online resources using the
appropriate URLs.
<P>Please read <A href="http://jogamp.org/jogl/doc/deployment/JOGL-DEPLOYMENT.html">JOGL
Deployment</A>. </P>
<H4><A name="applets">Applets</A> </H4>
<P>You might want to have a look at our <A href="http://jogamp.org/deployment/jogamp-current/jogl-test-applets.html">Test
page for JOGL Applet</A> </P>Here are documented Applet launch examples:
<OL>
  <LI><A href="http://jogamp.org/deployment/jogamp-current/jogl-applet-runner-newt-gears-normal-napplet.html">Pure
  Applet</A> (<B>recommended</B>)</LI>
  <LI><A href="http://jogamp.org/deployment/jogamp-current/jogl-applet-runner-newt-gears-normal.html">JNLP
  Applet w/ AppletLauncher-fallback </A></LI></OL>
<H4><A name="jnlpwebstart">JNLP / Webstart</A> </H4>
<P>Here is a documented <A href="http://jogamp.org/deployment/jogamp-current/jogl-applet-runner-newt-gears-normal.html">JNLP
Applet w/ AppletLauncher-fallback </A>, which also documents how to utilize JOGL
via WebStart with slight modifications. </P>
<H2><A name="joglapi">Using the JOGL API</A> </H2>
<H3><A name="gldrawableandglcontext">GLDrawable and GLContext</A> </H3>
<P>The APIs specify interfaces two low-level OpenGL abstractions: drawables and
contexts. An OpenGL drawable is effectively a surface upon which OpenGL
rendering will be performed. In order to perform rendering, an OpenGL rendering
context is needed. Contexts and drawables typically go hand-in-hand. More than
one context may be created for a particular drawable. In these abstractions, a
 context is always associated with exactly one drawable. </P>
<P>Most end users will not need to use these abstractions directly. However,
when sharing textures, display lists and other OpenGL objects between widgets,
the concrete identifier for the "namespace" for these objects is the GLContext.
</P>
<H3> GLProfile </H3>
<P>GLProfile instances maps OpenGL profiles introduced in OpenGL 3, please read
<A
href="http://jogamp.org/jogl/doc/Overview-OpenGL-Evolution-And-JOGL.html">this</A>
for more details. </P>
<H3> Creating a GLAutoDrawable </H3>
<P>Jogl provides three basic widgets into which OpenGL rendering can be
 performed. The GLCanvas is a heavyweight AWT widget which supports hardware
acceleration and which is intended to be the primary widget used by
applications. The GLJPanel is a fully Swing-compatible lightweight widget which
supports hardware acceleration but which is not as fast as the GLCanvas because
it typically reads back the frame buffer in order to draw it using Java2D. The
GLJPanel is intended to provide 100% correct Swing integration in the
circumstances where a GLCanvas can not be used. See <A href="http://java.sun.com/products/jfc/tsc/articles/mixing/">this
 article</A> on <A href="http://java.sun.com/products/jfc/tsc/">The Swing
Connection</A> for more information about mixing lightweight and heavyweight
widgets. See also the section on "Heavyweight and Lightweight Issues" below.
Recent work in the Mustang release of the JDK has sped up the GLJPanel
significantly when the Java2D OpenGL pipeline is enabled; see <A href="http://www.javagaming.org/forums/index.php?topic=10813.0">this
 forum discussion</A> for more details. GLWindow is a NEWT widget which supports
hardware acceleration and which  is intended to be the primary widget used by
AWT-less applications. </P>GLCanvas, GLWindow and GLJPanel implement a common
interface called GLAutoDrawable so applications can switch between them with
minimal code changes. The GLAutoDrawable interface provides
<UL>
  <LI> access to the GL object for calling OpenGL routines</LI>
  <LI> a callback mechanism (GLEventListener) for performing OpenGL
  rendering</LI>
  <LI> a <CODE>display()</CODE> method for forcing OpenGL rendering to  be
  performed synchronously</LI>
  <LI> AWT- and Swing-independent abstractions for getting and setting  the size
  of the widget and adding and removing event listeners</LI></UL>
<P>When creating GLCanvas, GLWindow and GLJPanel instances, the user may request
a certain set of OpenGL parameters in the form of a GLCapabilities object,
customize the format selection algorithm by specifying a GLCapabilitiesChooser,
share textures and display lists with other GLDrawables, and specify the display
device on which the GLAutoDrawable will be created (GLCanvas and GLWindow only).
</P>
<P>A GLCapabilities object specifies the OpenGL parameters for a newly-created
widget, such as the color, alpha,, z-buffer and accumulation buffer bit depths
and whether the widget is double-buffered. The default capabilities are loosely
specified but provide for truecolor RGB, a reasonably large depth buffer,
 double-buffered, with no alpha, stencil, or accumulation buffers.  </P>
<P>An application can override the default pixel format selection algorithm by
providing a GLCapabilitiesChooser to the GLCanvas or GLJPanel constructor. (Not
all platforms support the GLCapabilitiesChooser mechanism, however; it may be
ignored, in particular on Mac OS X where pixel format selection is very
different than on other platforms.) The chooseCapabilities method will be called
 with all of the available pixel formats as an array of GLCapabilities objects,
as well as the index indicating the window system's recommended choice; it
should return an integer index into this array. The DefaultGLCapabilitiesChooser
uses the window system's recommendation when it is available, and otherwise
attempts to use a platform-independent selection algorithm. </P>
<P>The GLJPanel can be made non-opaque according to Swing's rendering model, so
it can act as an overlay to other Swing or Java2D drawing. In order to enable
this, set up your GLCapabilities object with a non-zero alpha depth (a common
value is 8 bits) and call setOpaque(false) on the GLJPanel once it has been
created. Java2D rendering underneath it will then show through areas where
OpenGL has produced an alpha value less than 1.0. See the JGears and JRefract
 demos for examples of how to use this functionality. </P>
<H3> Writing a GLEventListener </H3>
<P>Applications implement the GLEventListener interface to perform OpenGL
 drawing via callbacks. When the methods of the GLEventListener are called, the
underlying OpenGL context associated with the drawable is already current. The
listener fetches the GL object out of the GLAutoDrawable and begins to perform
rendering. </P>
<P>The <CODE>init()</CODE> method is called when a new OpenGL context is created
for the given GLAutoDrawable. Any display lists or textures used during the
application's normal rendering loop can be safely initialized in
<CODE>init()</CODE>. It is important to note that because the underlying AWT
window may be destroyed and recreated while using the same GLCanvas and
GLEventListener, the GLEventListener's <CODE>init()</CODE> method may be called
more than once during the lifetime of the application. The init() method should
therefore be kept as short as possible and only contain the OpenGL
initialization required for the <CODE>display()</CODE> method to run properly.
It is the responsibility of the application to keep track of how its various
 OpenGL contexts share display lists, textures and other OpenGL objects so they
can be either be reinitialized or so that reinitialization can be skipped when
the <CODE>init()</CODE> callback is called. </P>
<P>Note also that the GLEventListener should be added to the GLAutoDrawable
before the GLAutoDrawable is shown or rendered to for the first time. If this is
not done, it is possible that the init() method will not be called on the
GLEventListener. JOGL does not maintain internal state to keep track of whether
init() has been called on a particular GLEventListener since the last time an
OpenGL context was created for that GLAutoDrawable. </P>
<P>The <CODE>display()</CODE> method is called to perform per-frame rendering.
The <CODE>reshape()</CODE> method is called when the drawable has been resized;
the default implementation automatically resizes the OpenGL viewport so often it
is not necessary to do any work in this method.  The
<CODE>displayChanged()</CODE> method is designed to allow applications to
support on-the-fly screen mode switching, but support for this is not yet
implemented so the body of this method should remain empty. </P>
<P>It is strongly recommended that applications always refetch the GL object out
of the GLAutoDrawable upon each call to the <CODE>init()</CODE>,
<CODE>display()</CODE> and <CODE>reshape()</CODE> methods and pass the GL object
down on the stack to any drawing routines, as opposed to storing the GL in a
field and referencing it from there. The reason is that multithreading issues
inherent to the AWT toolkit make it difficult to reason about which threads
certain operations are occurring on, and if the GL object is stored in a field
 it is unfortunately too easy to accidentally make OpenGL calls from a thread
that does not have a current context. This will usually cause the application to
crash. For more information please see the section on multithreading. </P>
<H3> Checking extensions and functions availability </H3>
<P>GLBase.isFunctionAvailable(String glFunctionName) and
 GLBase.isExtensionAvailable(String glExtensionName) allow to check whether
 OpenGL functions and extensions are available. </P>
<H3> Use of NIO buffers </H3>
<P>Use com.jogamp.common.nio.Buffers to create any NIO buffer intented to be
 used by JOGL in order to avoid native ordering and size problems. Jogl does
 not modify the position of a buffer passed to its methods but such a position
 affects its behaviour. Direct NIO buffers are faster and should be used when
 performances are important. Indirect NIO buffers can be used for non critical
 operations, for example to retrieve the value of an OpenGL constant. Keep in
 mind that direct NIO buffers are page-aligned and allocated in the native heap
 (whereas indirect NIO buffers are allocated in Java heap). Use the VM argument
 "-XX:MaxDirectMemorySize" to increase the maximum size of the direct memory if
 the creation of direct NIO buffers fails, use the VM argument "-Xmx" to
increase  the maximum size of Java heap if the creation of undirect NIO buffers
fails. </P>
<H3> Documentation of C language functions matching with Jogl methods </H3>
<P>Jogl documentation often refers to C language functions. You can find the
 documentation of these functions in OpenGL references pages <A href="http://www.opengl.org/sdk/docs/">here</A>.
</P>
<H3> Performance </H3>
<P>JOGL has a low memory footprint. It uses direct NIO buffers in order to avoid
 copying data both in Java heap and in the native heap when calling native
functions.  JOGL accesses OpenGL through JNI; as a JNI call only takes a few
nanoseconds, it  does not drive programs using JOGL noticeably slower than their
C/C++ equivalents. </P>
<H2> Using the Composable Pipeline </H2>
<P>Jogl supports the "composable pipeline" paradigm introduced by the Magician
Java binding for OpenGL. The DebugGL pipeline calls <CODE>glGetError</CODE>
after each OpenGL call, reporting any errors found. It can greatly speed up
development time because of its fine-grained error checking as opposed to the
manual error checking usually required in OpenGL programs written in C. The
TraceGL prints logging information upon each OpenGL call and is helpful when an
 application crash makes it difficult to see where the error occurred. </P>
<P>To use these pipelines, call <CODE>GLAutoDrawable.setGL</CODE> at the
 beginning of the <CODE>init</CODE> method in your GLEventListener. For example,
</P>
<PRE>class MyListener implements GLEventListener {
  public void init(GLDrawable drawable) {
    drawable.setGL(new DebugGL(drawable.getGL()));
    // ...
  }

  // ...
}
</PRE>
<P>Note that the GLAutoDrawable.setGL() method simply calls setGL() on the
default OpenGL context created by the GLAutoDrawable, so sophisticated
applications creating their own OpenGL contexts can use the composable pipeline
with these contexts by setting the GL object in the context object itself. The
composable pipeline needs to be re-installed every time GLContext.makeCurrent()
returns CONTEXT_CURRENT_NEW. </P>
<P>N.B: DebugGL and TraceGL have been splitted into several classes matching
 with all GL subclasses. </P>
<PRE>
if (drawable.getGL().isGL4bc()) {
    final GL4bc gl4bc = drawable.getGL().getGL4bc();
    drawable.setGL(new DebugGL4bc(gl4bc));
}
else {
    if (drawable.getGL().isGL4()) {
        final GL4 gl4 = drawable.getGL().getGL4();
        drawable.setGL(new DebugGL4(gl4));
    }
    else {
          if (drawable.getGL().isGL3bc()) {
              final GL3bc gl3bc = drawable.getGL().getGL3bc();
              drawable.setGL(new DebugGL3bc(gl3bc));
          }
          else {
              if (drawable.getGL().isGL3()) {
                  final GL3 gl3 = drawable.getGL().getGL3();
                  drawable.setGL(new DebugGL3(gl3));
              }
              else {
                  if (drawable.getGL().isGL2()) {
                      final GL2 gl2 = drawable.getGL().getGL2();
                      drawable.setGL(new DebugGL2(gl2));
                  }
              }
          }
     }
}

</PRE>
<H2> Heavyweight and Lightweight Issues </H2>
<P>As mentioned above, JOGL supplies both a heavyweight (GLCanvas) and a
 lightweight (GLJPanel) widget to be able to provide the fastest possible
performance for applications which need it as well as 100% correct Swing
integration, again for applications which need it. The GLCanvas usually provides
higher performance than the GLJPanel, though in recent releases the GLJPanel's
speed has been improved when the Java2D/OpenGL pipeline is active as described
in <A href="http://www.javagaming.org/forums/index.php?topic=10813.0">this forum
discussion</A>. Nonetheless, the GLCanvas can be used in almost every kind of
application except those using JInternalFrames. Please see the Swing Connection
article mentioned above for details on mixing heavyweight and lightweight
widgets. A couple of common pitfalls are described here. </P>
<P>When using JPopupMenus or Swing tool tips in conjunction with the GLCanvas,
it is necessary to disable the use of lightweight widgets for the popups. See
the methods <CODE>ToolTipManager.setLightWeightPopupEnabled</CODE>,
<CODE>JPopupMenu.setLightWeightPopupEnabled</CODE>, and
<CODE>JPopupMenu.setDefaultLightWeightPopupEnabled</CODE>. </P>
<P>There are occasionally problems with certain LayoutManagers and component
configurations where if a GLCanvas is placed in the middle of a set of
lightweight widgets then it may only grow and never shrink. These issues are
documented somewhat in <A href="https://jogl.dev.java.net/issues/show_bug.cgi?id=135">JOGL
Issue 135</A> and most recently in the thread <A href="http://javagaming.org/forums/index.php?topic=8699.0">"Resize
 behaviour"</A> in the JOGL forum. The root cause is behavior of the Canvas, and
in particular its ComponentPeer. The implementation of getPreferredSize() calls
getMinimumSize() and getMinimumSize() turns around and calls
Component.getSize(). This effectively means that the Canvas will report its
preferred size as being as large as the component has ever been. For some layout
managers this doesn't seem to matter, but for others like the BoxLayout it does.
See the test case attached to Issue 135 for an example. Replacing the GLCanvas
with an ordinary Canvas yields the same behavior. </P>
<P>One suggestion was to override getPreferredSize() so that if a preferred size
has not been set by the user, to default to (0, 0). This works fine for some
test cases but breaks all of the other JOGL demos because they use a different
LayoutManager. There appear to be a lot of interactions between heavyweight vs.
lightweight widgets and layout managers. One experiment which was done was to
override setSize() in GLCanvas to update the preferred size.  This works down to
the size specified by the user; if the window is resized any smeller the same
problem appears. If reshape() (the base routine of setSize(), setBounds(), etc.)
is changed to do the same thing, the demo breaks in the same way it originally
did. Therefore this solution is fragile because it isn't clear which of these
methods are used internally by the AWT and for what purposes. </P>
<P>There are two possible solutions, both application-specific. The best and
most portable appears to be to put the GLCanvas into a JPanel and set the
JPanel's preferred size to (0, 0). The JPanel will cause this constraint to be
enforced on its contained GLCanvas. The other workaround is to call
<CODE>setPreferredSize(new Dimension(0, 0))</CODE> on a newly-created GLCanvas;
this method is new in 1.5. </P>
<P>Another issue that occasionally arises on Windows is flickering during live
resizing of a GLCanvas. This is caused by the AWT's repainting the background of
the Canvas and can not be overridden on a per-Canvas basis, for example when
subclassing Canvas into GLCanvas.  The repainting of the background of Canvases
on Windows can be disabled by specifying the system property
<CODE>-Dsun.awt.noerasebackground=true</CODE>. Whether to specify this flag
depends on the application and should not be done universally, but instead on a
case-by-case basis. Some more detail is in the thread <A href="http://javagaming.org/forums/index.php?topic=8770.0">"TIP:
 JOGL + Swing flicker"</A> in the JOGL forum. </P>
<H2> SWT/AWT issues </H2>
<P>The AWT GLCanvas has to be created once the size of the frame that contains
it  is no more zero. It is highly advised to do it inside a component listener
 so that it is called when the frame is resized. This listener has to be
 immediately removed after the creation of the canvas. Laying out the frame (by
calling <CODE>doLayout()</CODE>) before starting the animator (or calling
<CODE>display()</CODE>) is necessary because  the width of the canvas cannot be
equal to zero and the SWT/AWT helper returns  AWT frames with a strange behavior
(width and height equal to zero, lazy layout  and validation). </P>
<H2> AWT Multithreading Issues </H2>Below statements incorrect!
<P>Jogl was designed to interoperate with the AWT, an inherently multithreaded
GUI toolkit. OpenGL, in contrast, was originally designed in single-threaded C
programming environments. For this reason Jogl provides a framework in which it
is possible to write correct multithreaded OpenGL applications using the
GLEventListener paradigm. </P>
<P>If an application written using Jogl interacts in any way with the mouse or
keyboard, the AWT is processing these events and the multithreaded aspects of
the program must be considered. </P>
<P>OpenGL applications usually behave in one of two ways: either they repaint
only on demand, for example when mouse input comes in, or they repaint
continually, regardless of whether user input is coming in. In the
repaint-on-demand model, the application can merely call
<CODE>GLAutoDrawable.display()</CODE> manually at the end of the mouse or
keyboard listener to cause repainting to be done. Alternatively if the
application knows the concrete type of the GLDrawable it can call repaint() to
have the painting scheduled for a later time. </P>
<P>In the continuous repaint model, the application typically has a main loop
which is calling <CODE>GLAutoDrawable.display()</CODE> repeatedly, or is using
the Animator class, which does this internally. In both of these cases the
OpenGL rendering will be done on this thread rather than the internal AWT event
queue thread which dispatches mouse and keyboard events. </P>
<P>Both of these models (repaint-on-demand and repaint continually) still
 require the user to think about which thread keyboard and mouse events are
coming in on, and which thread is performing the OpenGL rendering. OpenGL
rendering <B>may not</B> occur directly inside the mouse or keyboard handlers,
because the OpenGL context for the drawable is not current at this point (hence
the warning about storing a GL object in a field, where it can be fetched and
accidentally used by another thread). However, a mouse or keyboard listener may
invoke <CODE>GLAutoDrawable.display()</CODE>. </P>
<P>It is generally recommended that applications perform as little work as
possible inside their mouse and keyboard handlers to keep the GUI responsive.
However, since OpenGL commands can not be run from directly within the mouse or
keyboard event listener, the best practice is to store off state when the
listener is entered and retrieve this state during the next call to
<CODE>GLEventListener.display()</CODE>. </P>
<P>Furthermore, it is recommended that if there are long computational sequences
in the GLEventListener's <CODE>display</CODE> method which reference variables
which may be being simultaneously modified by the AWT thread (mouse and keyboard
listeners) that copies of these variables be made upon entry to
<CODE>display</CODE> and these copies be referenced throughout display() and the
methods it calls. This will prevent the values from changing while the OpenGL
rendering is being performed. Errors of this kind show up in many ways,
including certain kinds of flickering of the rendered image as certain pieces of
objects are rendered in one place and other pieces are rendered elsewhere in the
scene. Restructuring the display() method as described has solved all instances
of this kind of error that have been seen with Jogl to date. </P>
<P>Prior to Jogl 1.1 b10, the Jogl library attempted to give applications strict
control over which thread or threads performed OpenGL rendering. The
<CODE>setRenderingThread()</CODE>, <CODE>setNoAutoRedrawMode()</CODE> and
<CODE>display()</CODE> APIs were originally designed to allow the application to
create its own animation thread and avoid OpenGL context switching on platforms
that supported it. Unfortunately, serious stability issues caused by
 multithreading bugs in either vendors' OpenGL drivers or in the Java platform
implementation have arisen on three of Jogl's major supported platforms:
Windows, Linux and Mac OS X. In order to address these bugs, the threading model
in Jogl 1.1 b10 and later has changed. </P>
<P>All GLEventListener callbacks and other internal OpenGL context management
are now performed on one thread. (In the current implementation, this thread is
the AWT event queue thread, which is a thread internal to the implementation of
the AWT and which is always present when the AWT is being used. Future versions
of Jogl may change the thread on which the OpenGL work is performed.) When the
<CODE>GLAutoDrawable.display()</CODE> method is called from user code, it now
performs the work synchronously on the AWT event queue thread, even if the
calling thread is a different thread. The <CODE>setRenderingThread()</CODE>
optimization is now a no-op. The <CODE>setNoAutoRedrawMode()</CODE> API still
works as previously advertised, though now that all work is done on the AWT
event queue thread it no longer needs to be used in most cases. (It was
previously useful for working around certain kinds of OpenGL driver bugs.) </P>
<P>Most applications will not see a change in behavior from this change in the
Jogl implementation. Applications which use thread-local storage or complex
multithreading and synchronization may see a change in their control flow
requiring code changes. While it is strongly recommended to change such
applications to work under the new threading model, the old threading model can
be used by specifying the system property <CODE>-Djogl.1thread=auto</CODE> or
<CODE>-Djogl.1thread=false</CODE>. The "auto" setting is equivalent to the
behavior in 1.1 b09 and before, where on ATI cards the single-threaded mode
would be used. The "false" setting is equivalent to disabling the
single-threaded mode. "true" is now the default setting. </P>
<P>In the APIs the single-threaded behavior continues to be the default and the
<CODE>setRenderingThread()</CODE> and <CODE>setNoAutoRedrawMode()</CODE> APIs
have been removed. The public <CODE>Threading</CODE> class still provides some
control over the internal use of threads in the library as well as external
access to these mechanisms. </P>
<H2> Pbuffers </H2>
<P>Jogl exposes hardware-accelerated offscreen rendering (pbuffers) with a
minimal and platform-agnostic API. Several recent demos have been successfully
ported from C/C++ to Java using Jogl's pbuffer APIs. However, the pbuffer
support in Jogl remains one of the more experimental aspects of the package and
the APIs may need to change in the future. </P>
<P>To create a pbuffer, call <CODE>GLDrawableFactory.createGLPbuffer()</CODE>.
It is wise to call <CODE>GLDrawableFactory.canCreateGLPbuffer()</CODE> first to
ensure the graphics card has pbuffer support first. The pbuffer is created
 immediately and is available for rendering as soon as
<CODE>createGLPbuffer</CODE> returns. </P>
<P>A pbuffer is used in conjunction with the GLEventListener mechanism by
 calling its display() method. Rendering, as always, occurs while the pbuffer's
OpenGL context is current. There are render-to-texture options that can be
specified in the GLCapabilities for the pbuffer which can make it easier to
operate upon the resulting pixels. These APIs are however highly experimental
and not yet implemented on all platforms. </P>
<H2> GLU </H2>
<P>Jogl contains support for the GLU (OpenGL Utility Library) version 1.3. Jogl
originally supported GLU by wrapping the C version of the APIs, but over time,
and thanks to the contributions of several individuals, it now uses a pure-Java
version of SGI's GLU library. The pure Java port is enabled by default, and
addresses stability issues on certain Linux distributions as well as the lack of
native GLU 1.3 support on the Windows platform. In case of problems with the
Java port, the C version of the GLU library may be used by specifying the system
property <CODE>-Djogl.glu.nojava</CODE> on the command line. All of the same
functionality is exposed with both the Java and C versions of the GLU library;
currently NURBS support is the only missing feature on both sides. If you run
into problems with the Java port of the GLU library please file a bug using the
Issue Tracker on the Jogl home page. </P>
<P>To use the GLU, simply instantiate a GLU object via <CODE>new GLU()</CODE> at
the beginning of your program. The methods on the GLU object may be called at
any point when an OpenGL context is current. Because the GLU implementation is
not thread-safe, one GLU object should be created for each GLEventListener or
other entity performing OpenGL rendering in a given thread. </P>
<P>N.B: Some GLU features are only implemented in the subclass GLUgl2. </P>
<H2> More Resources </H2>
<P>Our <A href="http://jogamp.org/wiki/">Wiki pages</A>, have a look at the  <A
href="http://jogamp.org/wiki/index.php/Jogl_Tutorial">Jogl Tutorial</A> resource
listing. </P>
<P>The <A href="http://forum.jogamp.org/">JOGL forum</A> is the best place to
ask questions about the library. Many users, as well as the Jogl developers,
read this forum frequently, and the archived threads contain a lot of useful
information (which still needs to be distilled into documentation). </P>
<P>The <A href="http://jogamp.org/jogl-demos/www/">JOGL demos</A> provide
 several examples of usage of the library. </P>
<P>Pepijn Van Eeckhoudt, Kevin Duling and Abdul Bezrati have done <A href="http://pepijn.fab4.be/software/nehe-java-ports/">JOGL
ports of many of the the NeHe demos</A>. These are small examples of various
 pieces of OpenGL functionality. See also the <A
href="http://nehe.gamedev.net/">NeHe web site</A>. </P>
<P>For release information about the JOGL library, please see the  <A href="http://jogamp.org/wiki/index.php/Jogamp_Versioning_and_Releases">Jogamp
Versioning and Release</A>. </P>
<P>Please post on the <A href="http://forum.jogamp.org/">JOGL forum</A> if you
have a resource you'd like to add to this documentation or like to edit the <A
href="http://jogamp.org/wiki/index.php">Wiki Pages</A> yourself. </P>
<H2> Platform Notes </H2>
<H3> All Platforms </H3>
<P>The following issues, among others, are outstanding on all platforms: </P>
<UL>
  <LI> A few remaining stability issues, mostly on older graphics cards.</LI></UL>
<H3> Windows </H3>
<P>For correct operation, it is necessary to specify the system property
<CODE>-Dsun.java2d.noddraw=true</CODE> when running JOGL applications on
Windows; this system property disables the use of DirectDraw by Java2D. There
are driver-level incompatibilities between DirectDraw and OpenGL which manifest
themselves as application crashes, poor performance, bad flickering, and other
artifacts. This poor behavior may exhibit itself when OpenGL and DirectDraw are
simply used in the same application, not even just in the same window, so
disabling Java2D's DirectDraw pipeline and forcing it to use its GDI pipeline is
 the only way to work around these issues. Java Web Start applications may set
this system property by adding the following line to the
<CODE>&lt;resources&gt;</CODE> section of the JNLP file: <CODE>&lt;property
name="sun.java2d.noddraw" value="true"/&gt; </CODE> </P>
<H3> X11 Platforms (Linux, Solaris, ..) </H3>
<H3> Mac OS X </H3>The following issues remain with the Mac OS X port:
<UL>
  <LI> Due to the mechanism by which the Cocoa graphics system selects OpenGL
  pixel formats, the GLCapabilitiesChooser mechanism can not be implemented on
  Mac OS X as on other platforms. Currently the underlying Cocoa pixel format
  selection is used on an NSOpenGLPixelFormat derived from the settings in the
  GLCapabilities, and the GLCapabilitiesChooser is ignored. </LI></UL>
<H2> Version History </H2>
<P>JOGL's version history can be found online in the  <A href="http://jogamp.org/wiki/index.php/Jogamp_Versioning_and_Releases">Jogamp
Versioning and Release</A>. </P>
<P>The whole evolution of JOGL is described <A href="http://jogamp.org/jogl/doc/Overview-OpenGL-Evolution-And-JOGL.html">here</A>.
</P></DIV></DIV>
<DIV id="footer">
<DIV id="footer_left"><SPAN>JogAmp.org</SPAN>                    by <A href="http://jogamp.org/jogl/">http://jogamp.org/jogl/</A>
                   is licensed under a <BR><A href="http://creativecommons.org/licenses/by/3.0/us/">Creative
Commons Attribution 3.0 License</A>.
</DIV></DIV></DIV></BODY></HTML>
